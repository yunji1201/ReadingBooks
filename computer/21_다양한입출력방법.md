# 21강. 다양한 입출력 방법

> ⚡ 입출력 방식의 종류 : 프로그램 입출력 / 인터럽트 기반 입출력 / DMA 입출력

<img alt="img_42.png" src="img2/img_42.png" width="500"/>

---

## 1. 프로그램 입출력

- 프로그램 속 명령어로 입출력장치를 제어하는 방법
- 입출력 명령어로써 장치 컨트롤러와 상호작용
- CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어진다

### < 1-1 쓰기 과정 >

> 메모리에 저장된 정보를 하드 디스크에 백업하는 과정을 예시로 들어보자! <br>
> (= 하드 디스크에 새로운 정보 '쓰기')

#### (1) CPU는 하드디스크 컨트롤러의 제어 레지스터에 쓰기 명령 내보내기

<img alt="img_43.png" src="img2/img_43.png" width="500"/>

#### (2) CPU는 하드디스크 컨트롤러의 제어 레지스터에 쓰기 명령 내보내기

<img alt="img_44.png" src="img2/img_44.png" width="500"/>

#### (3-1) CPU는 상태 레지스터를 주기적으로 읽어보며 하드 디스크의 준비여부를 확인

#### (3-2) 하드 디스크가 준비되었다면 백업할 메모리의 정보를 데이터 레지스터에 쓰기

(아직 백업 작업 (쓰기 작업)이 끝나지 않았다면 1번부터 반복, 쓰기가 끝났다면 작업 종료)

<img alt="img_45.png" src="img2/img_45.png" width="500"/>

<img alt="img_46.png" src="img2/img_46.png" width="500"/>

그런데 여기에서 CPU가 어떻게 레지스터(입출력장치들의 주소)들을 인식할 수 있을까?

### < 1-2 프로그램 입출력 방식 >

- (1) 메모리 맵 입출력
    - 메모리에 접근하기 위한 주소공간과 입출력장치에 접근하기 위한 주소공간을 하나의 주소공간으로 간주하는 방법
    - <img alt="img_47.png" src="img2/img_47.png" width="350"/>
    - <img alt="img_48.png" src="img2/img_48.png" width="500"/>
    - 메모리 접근 명령어와 입출력 장치 접근 명령어와 같다
        - 그 이유는 하나의 주소공간을 가지고 있기 때문!


- (2) 고립형 입출력
    - 메모리를 위한 주소공간과 입출력을 위한 주소공간을 분리하는 방법
    - <img alt="img_50.png" src="img2/img_50.png" width="500"/>
    - 제어버스쪽을 보면 메모리 읽기/쓰기 선과 입출력장치 읽기/쓰기 선이 별도로 각각 나누어져 있는 것을 확인할 수 있다
    - <img alt="img_49.png" src="img2/img_49.png" width="500"/>
    - (입출력 읽기/쓰기 선을 활성화시키는) 입출력 전용 명령어 사용


- 정리
    - <img alt="img_51.png" src="img2/img_51.png" width="500"/>

---

## 2. 인터럽트 기반 입출력

- 하드웨어 인터럽트는 장치 컨트롤러에 의해 발생

<img alt="img_52.png" src="img2/img_52.png" width="500"/>

- 이렇게 되면 CPU는 CPU사이클을 알뜰살뜰 쓰면서 더 효율적으로 쓸 수 있는거임
    - 왜냐면 프로그램 입출력때보면 CPU는 상태레지스터를 '주기적으로' 읽어보면서 하드디스크의 준비여부를 확인하는데 인터럽트를 이용하면 요청신호가 오면 그때 시작하면 되니까 더 효율적이라는 거임
    - 인터럽트방식과 반대되는 즉, '주기적인' 방식은 '폴링'이라고 한다

### < 2-1 동시다발적인 인터럽트 >

<img alt="img_53.png" src="img2/img_53.png" width="400"/>

> 입출력장치가 많을 때 어떻게 처리할까??

#### (1) 인터럽트 발생 순서대로 처리

<img alt="img_54.png" src="img2/img_54.png" width="300"/>

- 간단하게 생각해보면 플래그 레지스터 속 인터럽트 비트를 비활성화 한채 인터럽트를 처리해서 순차적으로 처리 진행

#### (2) 우선순위를 반영해서 처리

<img alt="img_55.png" src="img2/img_55.png" width="500"/>

- NMI 즉 non maskable interrupt가 발생하면, 우선순위를 반영해서 처리한다
- NMU가 발생하면 플래그 제리스터 속 인터럽트 비트를 활성화한 채 입터렅르르 처리하는 경우

#### PIC (Programmable Interrupt Controller)

<img alt="img_56.png" src="img2/img_56.png" width="200"/> <br>
(그림을 보면 아래에 여러 핀들이 있는데 거기에 각각 장치컨트롤러들이 연결되는 것이다)

- 다중인터럽트를 처리하는 방식에는 다양한 방식이 있지만 그중 가장 대중적인 방식

1. 여러 장치 컨트롤러에 연결되어
2. 장치 컨트롤러의 하드웨어 인터럽트의 우선순위를 판단한 뒤 (NMI우선순위까지 판단하지는 않음)
3. CPU에게 지금 처리해야 하는 인터럽트가 무엇인지 판단하는 하드웨어

<img alt="img_57.png" src="img2/img_57.png" width="500"/>

<img alt="img_58.png" src="img2/img_58.png" width="500"/> <br>
(이렇게 보통 여러개가 한꺼번에 사용된다)

### 프로그램 입출력, 인터럽트 기반 입출력의 '공통점'

- 입출력장치와 메모리간의 데이터 이동은 **CPU**가 주도하고, <br> 이동하는 데이터도 반드시 **CPU**를 거친다

> 무슨뜻이지? 예시를 통해 생각해보자

- 입출력장치의 데이터를 메모리에 저장하는 경우,
- 하드디스크의 데이터 레지스터로부터 CPU로 읽어오게 되고, 이값을 다시 메모리로 쓰게된다

<img alt="img_59.png" src="img2/img_59.png" width="500"/>

- 메모링의 데이터를 입출력에 저장하는 경우,
- 메모리로부터 CPU가 읽어들여서, 읽어들인 값을 다시 장치 컨트롤러의 레지스터로 쓰게된다

<img alt="img_60.png" src="img2/img_60.png" width="500"/>

- 여기서 문제,
    - 이렇게 프로그램 입출력과 인터럽트 기반 입출력의 '공통점'은 **CPU**를 거치는데, <br> 가뜩이나 바쁜 CPU가 하드 디스크 백업과 같이 대용량 데이터를 이동한다면.....?

> 이러한 문제를 해결하기 위해 나온 것이 바로 'DMA 입출력'

---

## 3. DMA 입출력 (Direact Memory Access)

(매우중요)

<img alt="img_61.png" src="img2/img_61.png" width="600"/>

- CPU를 거치지 않고 입출력장치가 메모리에 직접적으로 접근하는 기능!

### < 3-1 DMA 입출력 과정 >

1. CPU는 DMA 컨트롤러에 입출력 작업을 명령
2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 입출력 작업을 수행
    - DMA 컨트롤러가 CPU 대행이라고 생각하면 돼
    - 이때, DMA컨트롤러는 필요한 경우 메모리에 직접 접근
3. 입출력 작업이 끝나면 DMA 컨트롤러는 인터럽트를 통해 CPU에 작업이 끝났음을 알림
    - 결과적으로, DMA 방식을 사용하면 CPU는 시작과 끝에만 관여하면 되니까 훨씬 효율적이다

<img alt="img_62.png" src="img2/img_62.png" width="500"/>
<img alt="img_63.png" src="img2/img_63.png" width="500"/>
<img alt="img_64.png" src="img2/img_64.png" width="500"/>

### < 3-2 DMA 입출력 과정의 문제 >

- 앞선 예시의 DMA 과정에서 시스템 버스를 이용 -> 그런데 시스템 버스는 공용자원이기에 동시사용 불가능!
- 즉, CPU가 시스템 버스를 사용할 때, DMA 컨트롤러는 시스템 버스를 사용할 수 없고, <br> DMA 컨트롤러가 시스템 버스를 사용할 때는 CPU가 시스템 버스를 사용할 수 없음


- 그래서 DMA 컨트롤러는 **두 가지의 방법**으로 사용한다
    - (1) CPU가 시스템 버스를 이용하지 않을 때마다 조금씩 시스템 버스 이용
    - (2) CPU가 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스 이용 - cycle stealing 이라고도 말함

<img alt="img_65.png" src="img2/img_65.png" width="500"/>

### < 3-3 시스템 버스 / 입출력 버스 >

- 시스템 버스를 불필요하게 두 번 이용하는 DMA 컨트롤러

<img alt="img_66.png" src="img2/img_66.png" width="500"/>

- 그래서 입출력 버스를 통해 시스템 버스의 이용 빈도 낮추기!

<img alt="img_67.png" src="img2/img_67.png" width="500"/>

<img alt="img_68.png" src="img2/img_68.png" width="500"/>